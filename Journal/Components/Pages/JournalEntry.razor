@page "/JournalEntry"
@layout MainLayout
@inject IJournalService JournalService
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime

<div class="container">
    <!-- Header -->
    <div class="header">
        <div class="header-actions">
            <div class="autosave-indicator">
                <span class="save-dot @(isSaved ? "saved" : "unsaved")"></span>
                <span>@(isSaved ? "Saved" : "Unsaved")</span>
            </div>
            <button class="btn btn-secondary" @onclick="PreviewEntry">Preview</button>
            <button class="btn btn-primary" @onclick="SaveEntry">@(isEditing ? "Update Entry" : "Publish Entry")</button>
        </div>
    </div>

    <!-- Main Entry Card -->
    <div class="entry-card">
        <!-- Entry Meta -->
        <div class="entry-meta">
            <div class="meta-row">
                <div class="meta-item">
                    <label>Date & Time</label>
                    <div class="date-time-display">
                        üìÖ @entry.CreatedAt.ToString("dddd, MMMM dd, yyyy ‚Ä¢ h:mm tt")
                    </div>
                </div>
            </div>

            <div class="meta-item">
                <label>Primary Mood (Required)</label>
                <div class="mood-selector">
                    @foreach (var mood in primaryMoods)
                    {
                        <div class="mood-option @(entry.Mood == mood.Name ? "selected" : "")" 
                             @onclick="() => SelectPrimaryMood(mood.Name)">
                            <span class="mood-emoji">@mood.Emoji</span>
                            <span class="mood-label">@mood.Name</span>
                        </div>
                    }
                </div>
            </div>

            @if (!string.IsNullOrEmpty(entry.Mood))
            {
                <div class="meta-item">
                    <label>Secondary Moods (Optional - pick up to 2)</label>
                    <div class="mood-selector secondary">
                        @foreach (var subMood in GetSubMoodsForPrimary(entry.Mood))
                        {
                            var isSelected = secondaryMoods.Contains(subMood.Name);
                            <div class="mood-option @(isSelected ? "selected" : "")" 
                                 @onclick="() => ToggleSecondaryMood(subMood.Name)">
                                <span class="mood-emoji">@subMood.Emoji</span>
                                <span class="mood-label">@subMood.Name</span>
                            </div>
                        }
                    </div>
                </div>
            }
        </div>

        <!-- Title Section -->
        <div class="title-section">
            <input type="text" class="title-input" placeholder="Give your entry a title..." 
                   @bind="entry.Title" @bind:after="OnContentChanged" />
        </div>

        <!-- Editor Toolbar Removed (Quill has its own) -->

        <!-- Content Editor -->
        <div class="editor-content">
            <div id="quill-editor" style="height: 400px; background: white;"></div>
        </div>

        <!-- Writing Prompts -->
        <div class="prompts-section">
            <h4>üí° Need inspiration? Try these prompts:</h4>
            <div class="prompts-list">
                @foreach (var prompt in prompts)
                {
                    <div class="prompt-chip" @onclick="() => UsePrompt(prompt)">@prompt</div>
                }
            </div>
        </div>

        <!-- Tags Section -->
        <div class="tags-section">
            <label>Tags</label>
            <div class="tags-container">
                @foreach (var tag in tags)
                {
                    <div class="tag">
                        @tag
                        <span class="tag-remove" @onclick="() => RemoveTag(tag)">√ó</span>
                    </div>
                }
            </div>

            <div class="prebuilt-tags">
                <span class="suggestion-label">Suggestions:</span>
                <div class="tag-suggestions">
                    @foreach (var tag in preBuiltTags)
                    {
                        var isAdded = tags.Contains(tag, StringComparer.OrdinalIgnoreCase);
                        <span class="tag-chip @(isAdded ? "added" : "")" @onclick="() => ToggleTag(tag)">
                            @tag
                        </span>
                    }
                </div>
            </div>

            <div class="tag-input-wrapper">
                <input type="text" class="tag-input" placeholder="Add custom tag..." 
                       @bind="newTag" @bind:event="oninput" @onkeypress="OnTagKeyPress" />
                <button class="add-tag-btn" @onclick="AddTag">Add Tag</button>
            </div>
        </div>

        <!-- Word Count -->
        <div class="word-count">
            @entry.WordCount words ‚Ä¢ @entry.CharacterCount characters
        </div>
    </div>
</div>

@implements IDisposable

@code {
    private JournalDisplayModel entry = new() { CreatedAt = DateTime.Now };
    private List<string> tags = new();
    private List<string> secondaryMoods = new();
    private string newTag = string.Empty;
    private bool isSaved = true;
    private bool isEditing = false;
    private System.Threading.Timer? autoSaveTimer;
    private DotNetObjectReference<JournalEntry>? objRef;

    private readonly List<(string Name, string Emoji)> primaryMoods = new()
    {
        ("Positive", "üòä"),
        ("Neutral", "üòê"),
        ("Negative", "üòü")
    };

    private readonly Dictionary<string, List<(string Name, string Emoji)>> subMoodsMap = new()
    {
        ["Positive"] = new() 
        { 
            ("Happy", "üòä"), ("Excited", "ü§©"), ("Relaxed", "üòå"), ("Grateful", "üôè"), ("Confident", "üòé") 
        },
        ["Neutral"] = new() 
        { 
            ("Calm", "üßò"), ("Thoughtful", "ü§î"), ("Curious", "üßê"), ("Nostalgic", "‚úâÔ∏è"), ("Bored", "üòë") 
        },
        ["Negative"] = new() 
        { 
            ("Sad", "üò¢"), ("Angry", "üò†"), ("Stressed", "üò´"), ("Lonely", "üë§"), ("Anxious", "üò∞") 
        }
    };

    private readonly List<string> prompts = new()
    {
        "What made today special?",
        "Three things I'm grateful for",
        "A challenge I overcame",
        "Something I learned today",
        "My goals for tomorrow"
    };

    private readonly List<string> preBuiltTags = new()
    {
        "Work", "Career", "Studies", "Family", "Friends", "Relationships",
        "Health", "Fitness", "Personal Growth", "Self-care", "Hobbies", "Travel",
        "Nature", "Finance", "Spirituality", "Birthday", "Holiday", "Vacation",
        "Celebration", "Exercise", "Reading", "Writing", "Cooking", "Meditation",
        "Yoga", "Music", "Shopping", "Parenting", "Projects", "Planning", "Reflection"
    };

    protected override async Task OnInitializedAsync()
    {
        objRef = DotNetObjectReference.Create(this);
        var uri = Navigation.ToAbsoluteUri(Navigation.Uri);
        if (uri.Query != null && uri.Query.Contains("id="))
        {
            var queryString = uri.Query.TrimStart('?');
            var parts = queryString.Split('&');
            foreach (var part in parts)
            {
                var keyValue = part.Split('=');
                if (keyValue.Length == 2 && keyValue[0] == "id" && int.TryParse(keyValue[1], out var id))
                {
                    await LoadEntry(id);
                    break;
                }
            }
        }
        else
        {
            var todayResult = await JournalService.HasEntryTodayAsync();
            if (todayResult.Success && todayResult.Data)
            {
                // Find today's entry and redirect to edit
                var allEntries = await JournalService.GetAllEntriesAsync();
                if (allEntries.Success && allEntries.Data != null)
                {
                    var todaysEntry = allEntries.Data.FirstOrDefault(e => e.CreatedAt.Date == DateTime.Today);
                    if (todaysEntry != null)
                    {
                        Navigation.NavigateTo($"/JournalEntry?id={todaysEntry.Id}");
                        return;
                    }
                }
            }
            entry.CreatedAt = DateTime.Now;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("initializeQuill", "quill-editor", entry.Content);
            await JSRuntime.InvokeVoidAsync("onQuillContentChanged", objRef);
        }
    }

    [JSInvokable]
    public async Task OnEditorContentChanged(string htmlContent)
    {
        entry.Content = htmlContent;
        isSaved = false;
        UpdateWordCount();
        StateHasChanged();
        
        // Auto-save after 2 seconds of inactivity
        autoSaveTimer?.Dispose();
        autoSaveTimer = new System.Threading.Timer(async _ => await AutoSave(), null, 2000, Timeout.Infinite);
    }

    private async Task LoadEntry(int id)
    {
        var result = await JournalService.GetEntryByIdAsync(id);
        if (result.Success && result.Data != null)
        {
            entry = result.Data;
            isEditing = true;
            if (!string.IsNullOrEmpty(entry.Tags))
            {
                tags = entry.Tags.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries).ToList();
            }
            if (!string.IsNullOrEmpty(entry.SecondaryMoods))
            {
                secondaryMoods = entry.SecondaryMoods.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries).ToList();
            }
            UpdateWordCount();
        }
    }

    private void OnContentChanged()
    {
        isSaved = false;
        UpdateWordCount();
        StateHasChanged();
        
        // Auto-save after 2 seconds of inactivity
        autoSaveTimer?.Dispose();
        autoSaveTimer = new System.Threading.Timer(async _ => await AutoSave(), null, 2000, Timeout.Infinite);
    }

    private async Task AutoSave()
    {
        if (!isSaved && !string.IsNullOrWhiteSpace(entry.Title) && !string.IsNullOrWhiteSpace(entry.Content))
        {
            entry.Tags = string.Join(", ", tags);
            entry.SecondaryMoods = string.Join(", ", secondaryMoods);
            var viewModel = new JournalViewModel
            {
                Title = entry.Title,
                Content = entry.Content,
                Mood = entry.Mood,
                SecondaryMoods = entry.SecondaryMoods,
                Tags = entry.Tags
            };

            if (isEditing)
            {
                await JournalService.UpdateEntryAsync(entry.Id, viewModel);
            }
            else
            {
                var result = await JournalService.CreateEntryAsync(viewModel);
                if (result.Success && result.Data != null)
                {
                    entry.Id = result.Data.Id;
                    isEditing = true;
                }
            }
            isSaved = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SaveEntry()
    {
        // Get latest content from Quill before saving
        entry.Content = await JSRuntime.InvokeAsync<string>("getQuillContent");
        
        if (string.IsNullOrWhiteSpace(entry.Title))
        {
            await JSRuntime.InvokeVoidAsync("alert", "Please enter a title for your entry.");
            return;
        }

        if (string.IsNullOrWhiteSpace(entry.Content) || entry.Content == "<p><br></p>")
        {
            await JSRuntime.InvokeVoidAsync("alert", "Please write some content for your entry.");
            return;
        }

        entry.Tags = string.Join(", ", tags);
        entry.SecondaryMoods = string.Join(", ", secondaryMoods);
        var viewModel = new JournalViewModel
        {
            Title = entry.Title,
            Content = entry.Content,
            Mood = entry.Mood,
            SecondaryMoods = entry.SecondaryMoods,
            Tags = entry.Tags
        };
        
        try
        {
            if (isEditing)
            {
                var result = await JournalService.UpdateEntryAsync(entry.Id, viewModel);
                if (result.Success)
                {
                    await JSRuntime.InvokeVoidAsync("alert", "Entry updated successfully!");
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("alert", $"Error: {result.Message}");
                    return;
                }
            }
            else
            {
                var result = await JournalService.CreateEntryAsync(viewModel);
                if (result.Success)
                {
                    isEditing = true;
                    await JSRuntime.InvokeVoidAsync("alert", "Entry published successfully!");
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("alert", $"Error: {result.Message}");
                    return;
                }
            }
            isSaved = true;
            Navigation.NavigateTo("/");
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error saving entry: {ex.Message}");
        }
    }

    private async Task PreviewEntry()
    {
        var markdown = await JSRuntime.InvokeAsync<string>("getQuillMarkdown");
        var preview = $"Title: {entry.Title}\n\nDate: {entry.CreatedAt:yyyy-MM-dd HH:mm}\nMood: {entry.Mood}\nSub-Moods: {string.Join(", ", secondaryMoods)}\nTags: {string.Join(", ", tags)}\n\n--- MARKDOWN ---\n\n{markdown}";
        await JSRuntime.InvokeVoidAsync("alert", preview);
    }

    private void SelectPrimaryMood(string moodName)
    {
        if (entry.Mood != moodName)
        {
            entry.Mood = moodName;
            secondaryMoods.Clear(); // Reset secondary moods when primary changes
            OnContentChanged();
        }
    }

    private List<(string Name, string Emoji)> GetSubMoodsForPrimary(string primaryMood)
    {
        if (string.IsNullOrEmpty(primaryMood)) return new();
        return subMoodsMap.ContainsKey(primaryMood) ? subMoodsMap[primaryMood] : new();
    }

    private void ToggleSecondaryMood(string moodName)
    {
        if (secondaryMoods.Contains(moodName))
        {
            secondaryMoods.Remove(moodName);
        }
        else if (secondaryMoods.Count < 2)
        {
            secondaryMoods.Add(moodName);
        }
        OnContentChanged();
    }

    private async Task UsePrompt(string prompt)
    {
        var currentContent = await JSRuntime.InvokeAsync<string>("getQuillContent");
        var newContent = string.IsNullOrEmpty(currentContent) || currentContent == "<p><br></p>" 
            ? $"<p><strong>{prompt}</strong></p><p><br></p>" 
            : $"{currentContent}<p><br></p><p><strong>{prompt}</strong></p><p><br></p>";
        
        await JSRuntime.InvokeVoidAsync("setQuillContent", newContent);
        entry.Content = newContent;
        OnContentChanged();
    }

    private void AddTag()
    {
        if (!string.IsNullOrWhiteSpace(newTag) && !tags.Contains(newTag.Trim(), StringComparer.OrdinalIgnoreCase))
        {
            tags.Add(newTag.Trim());
            newTag = string.Empty;
            OnContentChanged();
        }
    }

    private void ToggleTag(string tag)
    {
        if (tags.Contains(tag, StringComparer.OrdinalIgnoreCase))
        {
            tags.RemoveAll(t => t.Equals(tag, StringComparison.OrdinalIgnoreCase));
        }
        else
        {
            tags.Add(tag);
        }
        OnContentChanged();
    }

    private void RemoveTag(string tag)
    {
        tags.Remove(tag);
        OnContentChanged();
    }

    private void OnTagKeyPress(Microsoft.AspNetCore.Components.Web.KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            AddTag();
        }
    }

    private void UpdateWordCount()
    {
        if (string.IsNullOrWhiteSpace(entry.Content))
        {
            entry.WordCount = 0;
            entry.CharacterCount = 0;
            return;
        }

        // Simple HTML tag removal for counting
        var plainText = System.Text.RegularExpressions.Regex.Replace(entry.Content, "<.*?>", string.Empty);
        entry.WordCount = CountWords(plainText);
        entry.CharacterCount = plainText.Length;
    }

    private int CountWords(string text)
    {
        if (string.IsNullOrWhiteSpace(text))
            return 0;
        return text.Split(new[] { ' ', '\t', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries).Length;
    }

    public void Dispose()
    {
        autoSaveTimer?.Dispose();
        objRef?.Dispose();
    }
}
